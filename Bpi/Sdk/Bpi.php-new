<?php

use Bpi\Sdk\Authorization;
use Bpi\Sdk\Exception\SDKException;
use Bpi\Sdk\Item\BaseItem;
use Bpi\Sdk\Item\Node;
use Bpi\Sdk\NodeList;
use Bpi\Sdk\UserList;
use GuzzleHttp\Client as GuzzleHttpClient;
use GuzzleHttp\Exception\ClientException as GuzzleClientException;

/**
 * TODO please add a general description about the purpose of this class.
 */
// @codingStandardsIgnoreLine
class Bpi
{
    /**
     *
     * @var \Goutte\Client
     */
    protected $client;

    /**
     *
     * @var \Bpi\Sdk\Authorization
     */
    protected $authorization;

    /**
     *
     * @var string
     */
    protected $endpoint;

    /**
     * Create Bpi Client
     *
     * @param string $endpoint URL
     * @param string $agencyId Agency ID
     * @param string $publicKey App key
     * @param string $secret
     */
    public function __construct($endpoint, $agencyId, $publicKey, $secret)
    {
        $this->endpoint = $endpoint;
        $this->authorization = new Authorization($agencyId, $publicKey, $secret);
    }

    private function request($method, $url, array $data = [])
    {
        try {
            $this->client = new GuzzleHttpClient([
                'base_uri' => $this->endpoint,
                'headers' => [
                    'Auth' => $this->authorization->toHTTPHeader(),
                ],
            ]);

            $result = $this->client->request($method, $url, $data);

            return $result;
        } catch (GuzzleClientException $e) {
            throw new SDKException($e->getMessage(), $e->getCode(), $e);
        }
    }

    /**
     * Get list of node based on some conditions
     *
     * @param array $queries available keys are: amount, offset, filter, sort
     *   filter and sort requires nested arrays
     * @return \Bpi\Sdk\NodeList
     */
    public function searchNodes(array $query = array())
    {
        $result = $this->request('GET', '/node/collection', [
            'query' => $query,
        ]);
        $element = new \SimpleXMLElement((string)$result->getBody());

        return new NodeList($element);
    }

    /**
     * Push new node to BPI
     *
     * @param array $data TODO please add some documentation of this property.
     * @throws \InvalidArgumentException
     * @return \Bpi\Sdk\Item\Node
     */
    public function push(array $data)
    {
        $result = $this->request('POST', '/node', ['form_params' => $data]);
        $element = new \SimpleXMLElement((string)$result->getBody());

        return new Node($element->item[0]);
    }

    /**
     * Mark node as syndicated
     *
     * @param string $id BPI node ID
     * @return boolean operation status
     */
    public function syndicateNode($id)
    {
        $result = $this->request('GET', '/node/syndicated', ['query' => ['id' => $id]]);

        return $result->getStatusCode() === 200;
    }

    /**
     * Mark node as deleted
     *
     * @param string $id BPI node ID
     * @return boolean operation status
     */
    public function deleteNode($id)
    {
        $result = $this->request('GET', '/node/delete', ['query' => ['id' => $id]]);

        return $result->getStatusCode() === 200;
    }

    /**
     * Get statistics
     * Parameterformat: Y-m-d
     *
     * TODO How about using DateTimes here and convert to string when calling the
     * API?
     *
     * @param string $dateFrom
     * @param string $dateTo
     */
    public function getStatistics($dateFrom, $dateTo)
    {
        $result = $this->request('GET', '/statistics', ['query' => ['dateFrom' => $dateFrom, 'dateTo' => $dateTo]]);
        $element = new \SimpleXMLElement((string)$result->getBody());

        return new BaseItem($element);
    }

    /**
     * Get single Node by ID
     *
     * @param string $id BPI node ID
     * @return \Bpi\Sdk\Item\Node
     */
    public function getNode($id)
    {
        $result = $this->request('GET', '/node/item/' . $id);
        $element = new \SimpleXMLElement((string)$result->getBody());

        return new Node($element->item[0]);
    }

    /**
     * Get list of dictionaries
     *
     * @return array
     */
    public function getDictionaries()
    {
        $result = $this->request('GET', '/profile/dictionary');
        $element = new \SimpleXMLElement((string)$result->getBody());

        $dictionary = [];
        foreach ($element->xpath('/bpi/item') as $item) {
            $group = (string)$item->xpath('properties/property[@name = "group"]')[0];
            $name = (string)$item->xpath('properties/property[@name = "name"]')[0];
            if (!isset($dictionary[$group])) {
                $dictionary[$group] = [];
            }
            $dictionary[$group][] = $name;
        }

        return $dictionary;
    }

    // -----------------------------------------------------------------------------

    /**
     * Get list of channels.
     *
     * @param array $query available keys are: amount, offset, filter, sort
     *   filter and sort requires nested arrays
     * @return \Bpi\Sdk\NodeList
     */
    public function searchChannels($query = [])
    {
        $channels = $this->createGenericDocument();
        $channels->request('GET', $this->endpoint_url . '/channel/?' . http_build_query($query));
        $channels->setFacets();

        return new \Bpi\Sdk\ChannelList($channels);
    }

    /**
     * Create a new channel.
     *
     * @param string $name
     * @param string $description
     * @param string $adminId
     */
    public function createChannel(array $data)
    {
        $this->checkRequired($data, ['name', 'description', 'adminId']);
        $values = $this->apiRename($data, [
            'name' => 'name',
            'description' => 'channelDescription',
            'adminId' => 'editorId',
        ]);

        $channels = $this->createGenericDocument();
        $channels->request('POST', $this->endpoint_url . '/channel/', $values);

        return new \Bpi\Sdk\Item\Channel($channels);
    }

    /**
     * Get a channel by Id.
     *
     * @param string $id
     *   The channel id.
     *
     * @return Channel
     *   The channel if found.
     */
    public function getChannel($id)
    {
        $channels = $this->createGenericDocument();
        $channels->request('GET', $this->endpoint_url . '/channel/' . $id);

        return new \Bpi\Sdk\Item\Channel($channels);
    }

    /**
     * @param string $name
     * @param string $description
     * @param string $adminId
     */
    public function updateChannel($channelId, array $data)
    {
        $this->checkRequired($data, [ 'name', 'description' ]);

        $values = $this->apiRename($data, [
            'name' => 'channelName',
            'description' => 'channelDescription',
        ]);

        $channels = $this->createGenericDocument();
        $channels->request('POST', $this->endpoint_url . '/channel/edit/' . $channelId, $values);

        return new \Bpi\Sdk\Item\Channel($channels);
    }

    /**
     * @param string $name
     * @param string $description
     * @param string $adminId
     */
    public function deleteChannel($channelId)
    {
        $channels = $this->createGenericDocument();
        $channels->request('DELETE', $this->endpoint_url . '/channel/remove/' . $channelId);

        return $channels->status()->isSuccess();
    }

    public function addEditorToChannel($channelId, $adminId, $editorIds)
    {
        if (!is_array($editorIds)) {
            $editorIds = [ $editorIds ];
        }
        $values = [
            'channelId' => $channelId,
            'adminId' => $adminId,
            'users' => array_map(function ($editorId) {
                return [ 'editorId' => $editorId ];
            }, $editorIds),
        ];

        $channels = $this->createGenericDocument();
        $channels->request('POST', $this->endpoint_url . '/channel/add/editor', $values);

        $successes = [];
        // @see http://api.symfony.com/3.0/Symfony/Component/DomCrawler/Crawler.html
        $channels->filterXPath('result/success_list/item')->each(function ($el) use (&$successes) {
            $successes[] = $el->textContent;
        });

        return count($successes) == count($editorIds);
    }

    public function removeEditorFromChannel($channelId, $adminId, $editorIds)
    {
        if (!is_array($editorIds)) {
            $editorIds = [ $editorIds ];
        }
        $values = [
            'channelId' => $channelId,
            'adminId' => $adminId,
            'users' => array_map(function ($editorId) {
                return [ 'editorId' => $editorId ];
            }, $editorIds),
        ];

        $channels = $this->createGenericDocument();
        $channels->request('POST', $this->endpoint_url . '/channel/remove/editor', $values);

        $successes = [];
        $channels->filterXPath('result/success_list/item')->each(function ($el) use (&$successes) {
            $successes[] = $el->textContent;
        });

        return count($successes) == count($editorIds);
    }

    public function getChannelsByUser($userId)
    {
        $channels = $this->createGenericDocument();
        $channels->request('GET', $this->endpoint_url . '/channel/user/' . $userId);

        return new \Bpi\Sdk\ChannelList($channels);
    }

    public function addNodeToChannel($channelId, $editorId, $nodeIds)
    {
        if (!is_array($nodeIds)) {
            $nodeIds = [ $nodeIds ];
        }
        $values = [
            'channelId' => $channelId,
            'editorId' => $editorId,
            'nodes' => array_map(function ($nodeId) {
                return [ 'nodeId' => $nodeId ];
            }, $nodeIds),
        ];

        $channels = $this->createGenericDocument();
        $channels->request('POST', $this->endpoint_url . '/channel/add/node', $values);

        $successes = [];
        $channels->filterXPath('result/success_list/item')->each(function ($el) use (&$successes) {
            $successes[] = $el->textContent;
        });

        return count($successes) == count($nodeIds);
    }

    public function removeNodeFromChannel($channelId, $editorId, $nodeIds)
    {
        if (!is_array($nodeIds)) {
            $nodeIds = [ $nodeIds ];
        }
        $values = [
            'channelId' => $channelId,
            'editorId' => $editorId,
            'nodes' => array_map(function ($nodeId) {
                return [ 'nodeId' => $nodeId ];
            }, $nodeIds),
        ];

        $channels = $this->createGenericDocument();
        $channels->request('POST', $this->endpoint_url . '/channel/remove/node', $values);

        $successes = [];
        $channels->filterXPath('result/success_list/item')->each(function ($el) use (&$successes) {
            $successes[] = $el->textContent;
        });

        return count($successes) == count($nodeIds);
    }

    // -----------------------------------------------------------------------------

    /**
     * Get list of users based on conditions
     *
     * @param array $queries available keys are: search, amount, offset, filter, sort
     *   filter and sort requires nested arrays
     * @return \Bpi\Sdk\UserList
     */
    public function searchUsers($query = [])
    {
        $result = $this->request('GET', '/user/', [
            'query' => $query,
        ]);
        $element = new \SimpleXMLElement((string)$result->getBody());

        return new UserList($element);
    }

    public function createUser(array $data)
    {
        $this->checkRequired($data, [ 'externalId', 'email' ]);

        $values = $this->apiRename($data, [
            'externalId' => 'externalId',
            'email' => 'email',
            'firstName' => 'userFirstName',
            'lastName' => 'userLastName',
        ]);

        $users = $this->createGenericDocument();
        $users->request('POST', $this->endpoint_url . '/user/', $values);

        return new \Bpi\Sdk\Item\User($users);
    }

    public function getUser($id)
    {
        $users = $this->createGenericDocument();
        $users->request('GET', $this->endpoint_url . '/user/' . $id);

        return new \Bpi\Sdk\Item\User($users);
    }

    /**
     * @param string $userId
     * @param array $data
     */
    public function updateUser($userId, array $data)
    {
        $this->checkRequired($data, []);

        $values = $this->apiRename($data, [
            'externalId' => 'externalId',
            'email' => 'email',
            'firstName' => 'userFirstName',
            'lastName' => 'userLastName',
        ]);

        $users = $this->createGenericDocument();
        $users->request('POST', $this->endpoint_url . '/user/edit/' . $userId, $values);

        return new \Bpi\Sdk\Item\User($users);
    }

    /**
     * @param string $name
     * @param string $description
     * @param string $adminId
     */
    public function deleteUser($userId)
    {
        $users = $this->createGenericDocument();
        $users->request('DELETE', $this->endpoint_url . '/user/remove/' . $userId);

        return $users->status()->isSuccess();
    }

    /**
     * @param string $userId
     * @param array $data
     *
     * @return Subscription
     */
    public function createSubscription($userId, array $data)
    {
        $this->checkRequired($data, [ 'title', 'filter' ]);

        $values = $data;
        $values['filter'] = json_encode($values['filter']);
        $values['userId'] = $userId;

        $users = $this->createGenericDocument();
        $users->request('POST', $this->endpoint_url . '/user/subscription', $values);

        return new \Bpi\Sdk\Item\User($users);
    }

    /**
     * @param string $userId
     * @param string $title
     */
    public function deleteSubscription($userId, $title)
    {
        $values = [
            'userId' => $userId,
            'subscriptionTitle' => $title,
        ];

        $users = $this->createGenericDocument();
        $users->request('POST', $this->endpoint_url . '/user/subscription/remove', $values);

        return new \Bpi\Sdk\Item\User($users);
    }

    protected function checkRequired(array $data, array $required)
    {
        foreach ($required as $name) {
            if (!isset($data[$name])) {
                throw new \InvalidArgumentException(sprintf('Field [%s] is required', (string)$name));
            }
        }
    }

    protected function apiRename(array $data, array $apiNames)
    {
        $values = [];
        foreach ($data as $name => $value) {
            if (isset($apiNames[$name])) {
                $values[$apiNames[$name]] = $value;
            }
        }
        return $values;
    }
}
